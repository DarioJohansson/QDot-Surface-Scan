from utils.common import zmq_exec


# The Time Controller Counter class: 
'''
This class defines an object which can be summoned to represent the counter functionality of the TC1000 in a running code.
It can be used as follows: 
counter = TCCounter(tc)

"counter" is now an initiated object which has all the relevant functionalities for counting photons coming into the input channels. 
By initiating the counter object only by specifying tc;  the integration time, input channel, mode and verbose fields are left default. 

tc is a necessary input field and it also represents an object, in this case it's a connection object which is generated by a function in the utils.common
module. 
The connect() function accepts and IP address and a port and returns a connection contect object, if connection is successful, which is fed into the counter object in
order for it to work. it is the reference which is used to physically communicate between code controller and TC device.




An example of a fully operating code snippet is as follows:

##START

from utils.common import zmq_exec, connect

tc = connect('169.254.207.101', 5555)       # This will create the tc connection object.
counter = TCCounter(tc)                     # Creates a counter by using the existing connection 

if counter.enabled():                       # checks if it is enabled.
    count = counter.count()                 # Returns the photon count measured in the integration window, defaulting to 1000ms.
    print(count)                            # Prints the count to console
else:
    counter.enable_input()                  
    count = counter.count()                 
    print(count) 

counter.disable_input()                     # disables counting routine on the controller.


##END

It's a stupid code snippet but it's just to prove a point.
In python, objects can store unique variables, which are useful to contextualise the single object based on it's status.
This object will be used to do a counting intensity map scan of the sample, since the operation is lightning fast and doesn't require accuracy.



'''
class TCCounter:
    def __init__(self, tc, int_time_ms: int = 1000, input: int|str = 'start', mode: str = "cycle", verbose: bool = False):
        self.tc = tc
        self.verbose = verbose

        if input.upper() == 'START':
            self.input='STAR'
        elif type(input) == int and input in range(1,4):
            self.input=f'INPU{input}'
        else:
            raise ValueError(f'Input needs to be "start" or an integer number from 1 to 4')
        # add sanity checks for god's sake.

        int_time_response = zmq_exec(self.tc, f"{self.input}:COUN:INTE {int_time_ms}")
        mode_response = zmq_exec(self.tc, f"{self.input}:COUN:MODE {mode.upper()}")

        if self.verbose:
            print(f"Integration Time Response: {int_time_response}\nCounter Mode Response: {mode_response}")

    def enabled(self) -> bool:
        if zmq_exec(self.tc, f"{self.input}:ENAB?") == 'ON':
            return True
        else:
            return False
    
    def reset(self):
        response = zmq_exec(self.tc, f"{self.input}:COUN:RESE")
        if self.verbose:
            print(response)
    
    def enable_input(self) -> bool:
        if self.enabled():
            return True
        else:
            response = zmq_exec(self.tc, f"{self.input}:ENAB")
            if response == 'Value set to ON':
                return True
            else:
                if self.verbose:
                    print(response)
                return False
        
    def disable_input(self) -> bool:
        if not self.enabled():
            return True
        else:
            response = zmq_exec(self.tc, f"{self.input}:ENAB OFF")
        if response == 'Value set to OFF':
            return True
        else:
            if self.verbose:
                print(response)
            return False
        
    def mode(self, mode: str|None = None) -> str|bool:
        if not mode:
            return zmq_exec(self.tc, f'{self.input}:COUN:MODE?').lower()
        else:
            mode = mode.upper()
            if mode == 'CYCLE':
                mode = 'CYCLe'
            elif mode == 'ACCUM':
                mode = 'ACCUm'
            else:
                raise ValueError(f"Mode {mode} not supported.")
            
            response = zmq_exec(self.tc, f'{self.input}:COUN:MODE {mode}')
            
            if response == f'Value set to {mode}':
                return True
            else:
                if self.verbose:
                    print(response)
                return False
    
    def count(self) -> int|None:
        try:
            value = int(zmq_exec(self.tc, f'{self.input}:COUN?'))
            return value
        except ValueError as e:
            print(f"Counter is throwing errors: {e}")
    
    

        